## Generated by dust (version 0.15.1) - do not edit
seir <- R6::R6Class(
  "dust",
  cloneable = FALSE,

  private = list(
    pars_ = NULL,
    pars_multi_ = NULL,
    index_ = NULL,
    info_ = NULL,
    n_threads_ = NULL,
    n_particles_ = NULL,
    n_particles_each_ = NULL,
    shape_ = NULL,
    ptr_ = NULL,
    gpu_config_ = NULL,
    ode_control_ = NULL,
    methods_ = NULL,
    param_ = list(beta = list(has_default = TRUE, default_value = 0.2, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     dt = list(has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     sigma = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE)),
    reload_ = NULL
  ),

  public = list(
    initialize = function(pars, time, n_particles, n_threads = 1L,
                          seed = NULL, pars_multi = FALSE,
                          deterministic = FALSE,
                          gpu_config = NULL, ode_control = NULL) {
      if (is.null(gpu_config)) {
        private$methods_ <- list(
           alloc = dust_cpu_seir_alloc,
           run = dust_cpu_seir_run,
           simulate = dust_cpu_seir_simulate,
           run_adjoint = dust_cpu_seir_run_adjoint,
           set_index = dust_cpu_seir_set_index,
           n_state = dust_cpu_seir_n_state,
           update_state = dust_cpu_seir_update_state,
           state = dust_cpu_seir_state,
           time = dust_cpu_seir_time,
           reorder = dust_cpu_seir_reorder,
           resample = dust_cpu_seir_resample,
           rng_state = dust_cpu_seir_rng_state,
           set_rng_state = dust_cpu_seir_set_rng_state,
           set_n_threads = dust_cpu_seir_set_n_threads,
           set_data = dust_cpu_seir_set_data,
           compare_data = dust_cpu_seir_compare_data,
           filter = dust_cpu_seir_filter,
           set_stochastic_schedule = dust_cpu_seir_set_stochastic_schedule,
           ode_statistics = dust_cpu_seir_ode_statistics)
      } else {
        private$methods_ <- list(alloc = function(...) {
          stop("GPU support not enabled for this object")
        })
      }
      res <- private$methods_$alloc(pars, pars_multi, time, n_particles,
                        n_threads, seed, deterministic, gpu_config, ode_control)
      private$pars_ <- pars
      private$pars_multi_ <- pars_multi
      private$n_threads_ <- n_threads
      private$ptr_ <- res[[1L]]
      private$info_ <- res[[2L]]
      private$shape_ <- res[[3L]]
      private$gpu_config_ <- res[[4L]]
      private$ode_control_ <- res[[5L]]
      private$n_particles_ <- prod(private$shape_)
      if (pars_multi) {
        private$n_particles_each_ <- private$n_particles_ / length(pars)
      } else {
        private$n_particles_each_ <- private$n_particles_
      }
    },

    name = function() {
      "seir"
    },

    param = function() {
      private$param_
    },

    run = function(time_end) {
      m <- private$methods_$run(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    simulate = function(time_end) {
      m <- private$methods_$simulate(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    run_adjoint = function() {
      res <- private$methods_$run_adjoint(private$ptr_)
      ## This approach may want to change, because it won't cope well
      ## with cases where are gradient is structured with respect to
      ## some parameters, but perhaps it's still a reasonable thing to
      ## do? While we have array-free models it's fine though.
      nms <- private$info_$adjoint
      if (!is.null(nms) && length(nms) == length(res$gradient)) {
        names(res$gradient) <- nms
      }
      res
    },

    set_index = function(index) {
      private$methods_$set_index(private$ptr_, index)
      private$index_ <- index
      invisible()
    },

    index = function() {
      private$index_
    },

    ode_control = function() {
      private$ode_control_
    },

    ode_statistics = function() {
      private$methods_$ode_statistics(private$ptr_)
    },

    n_threads = function() {
      private$n_threads_
    },

    n_state = function() {
      private$methods_$n_state(private$ptr_)
    },

    n_particles = function() {
      private$n_particles_
    },

    n_particles_each = function() {
      private$n_particles_each_
    },

    shape = function() {
      private$shape_
    },

    update_state = function(pars = NULL, state = NULL, time = NULL,
                            set_initial_state = NULL, index = NULL,
                            reset_step_size = NULL) {
      info <- private$methods_$update_state(private$ptr_, pars, state, time,
                                          set_initial_state, index,
                                          reset_step_size)
      if (!is.null(pars)) {
        private$info_ <- info
        private$pars_ <- pars
      }
      invisible()
    },

    state = function(index = NULL) {
      m <- private$methods_$state(private$ptr_, index)
      rownames(m) <- names(index)
      m
    },

    time = function() {
      private$methods_$time(private$ptr_)
    },

    set_stochastic_schedule = function(time) {
      private$methods_$set_stochastic_schedule(private$ptr_, time)
      invisible()
    },

    reorder = function(index) {
      storage.mode(index) <- "integer"
      private$methods_$reorder(private$ptr_, index)
      invisible()
    },

    resample = function(weights) {
      invisible(private$methods_$resample(private$ptr_, weights))
    },

    info = function() {
      private$info_
    },

    pars = function() {
      private$pars_
    },

    rng_state = function(first_only = FALSE, last_only = FALSE) {
      private$methods_$rng_state(private$ptr_, first_only, last_only)
    },

    set_rng_state = function(rng_state) {
      private$methods_$set_rng_state(private$ptr_, rng_state)
      invisible()
    },

    has_openmp = function() {
      dust_cpu_seir_capabilities()[["openmp"]]
    },

    has_gpu_support = function(fake_gpu = FALSE) {
      if (fake_gpu) {
        FALSE
      } else {
        dust_cpu_seir_capabilities()[["gpu"]]
      }
    },

    has_compare = function() {
      dust_cpu_seir_capabilities()[["compare"]]
    },

    real_size = function() {
      dust_cpu_seir_capabilities()[["real_size"]]
    },

    time_type = function() {
      dust_cpu_seir_capabilities()[["time_type"]]
    },

    rng_algorithm = function() {
      dust_cpu_seir_capabilities()[["rng_algorithm"]]
    },

    uses_gpu = function(fake_gpu = FALSE) {
      real_gpu <- private$gpu_config_$real_gpu
      !is.null(real_gpu) && (fake_gpu || real_gpu)
    },

    n_pars = function() {
      if (private$pars_multi_) length(private$pars_) else 0L
    },

    set_n_threads = function(n_threads) {
      prev <- private$n_threads_
      private$methods_$set_n_threads(private$ptr_, n_threads)
      private$n_threads_ <- n_threads
      invisible(prev)
    },

    set_data = function(data, shared = FALSE) {
      private$methods_$set_data(private$ptr_, data, shared)
    },

    compare_data = function() {
      private$methods_$compare_data(private$ptr_)
    },

    filter = function(time_end = NULL, save_trajectories = FALSE,
                      time_snapshot = NULL, min_log_likelihood = NULL) {
      private$methods_$filter(private$ptr_, time_end, save_trajectories,
                              time_snapshot, min_log_likelihood)
    },

    gpu_info = function() {
      ret <- dust_seir_gpu_info()
      ret$devices <- as.data.frame(ret$devices, stringsAsFactors = FALSE)
      parent <- parent.env(environment())
      if (ret$has_cuda && exists("private", parent, inherits = FALSE)) {
        ret$config <- private$gpu_config_
      }
      ret
    }
  ))
class(seir) <- c("dust_generator", class(seir))
seirdage <- R6::R6Class(
  "dust",
  cloneable = FALSE,

  private = list(
    pars_ = NULL,
    pars_multi_ = NULL,
    index_ = NULL,
    info_ = NULL,
    n_threads_ = NULL,
    n_particles_ = NULL,
    n_particles_each_ = NULL,
    shape_ = NULL,
    ptr_ = NULL,
    gpu_config_ = NULL,
    ode_control_ = NULL,
    methods_ = NULL,
    param_ = list(dt = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     E_ini = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     I_ini = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     m = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     N_age = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     p_death = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     S_ini = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     beta = list(has_default = TRUE, default_value = 0.0165, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     sigma = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE)),
    reload_ = NULL
  ),

  public = list(
    initialize = function(pars, time, n_particles, n_threads = 1L,
                          seed = NULL, pars_multi = FALSE,
                          deterministic = FALSE,
                          gpu_config = NULL, ode_control = NULL) {
      if (is.null(gpu_config)) {
        private$methods_ <- list(
           alloc = dust_cpu_seirdage_alloc,
           run = dust_cpu_seirdage_run,
           simulate = dust_cpu_seirdage_simulate,
           run_adjoint = dust_cpu_seirdage_run_adjoint,
           set_index = dust_cpu_seirdage_set_index,
           n_state = dust_cpu_seirdage_n_state,
           update_state = dust_cpu_seirdage_update_state,
           state = dust_cpu_seirdage_state,
           time = dust_cpu_seirdage_time,
           reorder = dust_cpu_seirdage_reorder,
           resample = dust_cpu_seirdage_resample,
           rng_state = dust_cpu_seirdage_rng_state,
           set_rng_state = dust_cpu_seirdage_set_rng_state,
           set_n_threads = dust_cpu_seirdage_set_n_threads,
           set_data = dust_cpu_seirdage_set_data,
           compare_data = dust_cpu_seirdage_compare_data,
           filter = dust_cpu_seirdage_filter,
           set_stochastic_schedule = dust_cpu_seirdage_set_stochastic_schedule,
           ode_statistics = dust_cpu_seirdage_ode_statistics)
      } else {
        private$methods_ <- list(alloc = function(...) {
          stop("GPU support not enabled for this object")
        })
      }
      res <- private$methods_$alloc(pars, pars_multi, time, n_particles,
                        n_threads, seed, deterministic, gpu_config, ode_control)
      private$pars_ <- pars
      private$pars_multi_ <- pars_multi
      private$n_threads_ <- n_threads
      private$ptr_ <- res[[1L]]
      private$info_ <- res[[2L]]
      private$shape_ <- res[[3L]]
      private$gpu_config_ <- res[[4L]]
      private$ode_control_ <- res[[5L]]
      private$n_particles_ <- prod(private$shape_)
      if (pars_multi) {
        private$n_particles_each_ <- private$n_particles_ / length(pars)
      } else {
        private$n_particles_each_ <- private$n_particles_
      }
    },

    name = function() {
      "seirdage"
    },

    param = function() {
      private$param_
    },

    run = function(time_end) {
      m <- private$methods_$run(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    simulate = function(time_end) {
      m <- private$methods_$simulate(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    run_adjoint = function() {
      res <- private$methods_$run_adjoint(private$ptr_)
      ## This approach may want to change, because it won't cope well
      ## with cases where are gradient is structured with respect to
      ## some parameters, but perhaps it's still a reasonable thing to
      ## do? While we have array-free models it's fine though.
      nms <- private$info_$adjoint
      if (!is.null(nms) && length(nms) == length(res$gradient)) {
        names(res$gradient) <- nms
      }
      res
    },

    set_index = function(index) {
      private$methods_$set_index(private$ptr_, index)
      private$index_ <- index
      invisible()
    },

    index = function() {
      private$index_
    },

    ode_control = function() {
      private$ode_control_
    },

    ode_statistics = function() {
      private$methods_$ode_statistics(private$ptr_)
    },

    n_threads = function() {
      private$n_threads_
    },

    n_state = function() {
      private$methods_$n_state(private$ptr_)
    },

    n_particles = function() {
      private$n_particles_
    },

    n_particles_each = function() {
      private$n_particles_each_
    },

    shape = function() {
      private$shape_
    },

    update_state = function(pars = NULL, state = NULL, time = NULL,
                            set_initial_state = NULL, index = NULL,
                            reset_step_size = NULL) {
      info <- private$methods_$update_state(private$ptr_, pars, state, time,
                                          set_initial_state, index,
                                          reset_step_size)
      if (!is.null(pars)) {
        private$info_ <- info
        private$pars_ <- pars
      }
      invisible()
    },

    state = function(index = NULL) {
      m <- private$methods_$state(private$ptr_, index)
      rownames(m) <- names(index)
      m
    },

    time = function() {
      private$methods_$time(private$ptr_)
    },

    set_stochastic_schedule = function(time) {
      private$methods_$set_stochastic_schedule(private$ptr_, time)
      invisible()
    },

    reorder = function(index) {
      storage.mode(index) <- "integer"
      private$methods_$reorder(private$ptr_, index)
      invisible()
    },

    resample = function(weights) {
      invisible(private$methods_$resample(private$ptr_, weights))
    },

    info = function() {
      private$info_
    },

    pars = function() {
      private$pars_
    },

    rng_state = function(first_only = FALSE, last_only = FALSE) {
      private$methods_$rng_state(private$ptr_, first_only, last_only)
    },

    set_rng_state = function(rng_state) {
      private$methods_$set_rng_state(private$ptr_, rng_state)
      invisible()
    },

    has_openmp = function() {
      dust_cpu_seirdage_capabilities()[["openmp"]]
    },

    has_gpu_support = function(fake_gpu = FALSE) {
      if (fake_gpu) {
        FALSE
      } else {
        dust_cpu_seirdage_capabilities()[["gpu"]]
      }
    },

    has_compare = function() {
      dust_cpu_seirdage_capabilities()[["compare"]]
    },

    real_size = function() {
      dust_cpu_seirdage_capabilities()[["real_size"]]
    },

    time_type = function() {
      dust_cpu_seirdage_capabilities()[["time_type"]]
    },

    rng_algorithm = function() {
      dust_cpu_seirdage_capabilities()[["rng_algorithm"]]
    },

    uses_gpu = function(fake_gpu = FALSE) {
      real_gpu <- private$gpu_config_$real_gpu
      !is.null(real_gpu) && (fake_gpu || real_gpu)
    },

    n_pars = function() {
      if (private$pars_multi_) length(private$pars_) else 0L
    },

    set_n_threads = function(n_threads) {
      prev <- private$n_threads_
      private$methods_$set_n_threads(private$ptr_, n_threads)
      private$n_threads_ <- n_threads
      invisible(prev)
    },

    set_data = function(data, shared = FALSE) {
      private$methods_$set_data(private$ptr_, data, shared)
    },

    compare_data = function() {
      private$methods_$compare_data(private$ptr_)
    },

    filter = function(time_end = NULL, save_trajectories = FALSE,
                      time_snapshot = NULL, min_log_likelihood = NULL) {
      private$methods_$filter(private$ptr_, time_end, save_trajectories,
                              time_snapshot, min_log_likelihood)
    },

    gpu_info = function() {
      ret <- dust_seirdage_gpu_info()
      ret$devices <- as.data.frame(ret$devices, stringsAsFactors = FALSE)
      parent <- parent.env(environment())
      if (ret$has_cuda && exists("private", parent, inherits = FALSE)) {
        ret$config <- private$gpu_config_
      }
      ret
    }
  ))
class(seirdage) <- c("dust_generator", class(seirdage))
seirhdage <- R6::R6Class(
  "dust",
  cloneable = FALSE,

  private = list(
    pars_ = NULL,
    pars_multi_ = NULL,
    index_ = NULL,
    info_ = NULL,
    n_threads_ = NULL,
    n_particles_ = NULL,
    n_particles_each_ = NULL,
    shape_ = NULL,
    ptr_ = NULL,
    gpu_config_ = NULL,
    ode_control_ = NULL,
    methods_ = NULL,
    param_ = list(dt = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     E_ini = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     I_ini = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     m = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     n_age = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     p_C = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_D = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_G = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_H = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     S_ini = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     beta = list(has_default = TRUE, default_value = 0.03, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_A = list(has_default = TRUE, default_value = 0.2, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_C = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_G = list(has_default = TRUE, default_value = list("/", 1L, 3L), rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_H = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_P = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     sigma = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     theta_A = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE)),
    reload_ = NULL
  ),

  public = list(
    initialize = function(pars, time, n_particles, n_threads = 1L,
                          seed = NULL, pars_multi = FALSE,
                          deterministic = FALSE,
                          gpu_config = NULL, ode_control = NULL) {
      if (is.null(gpu_config)) {
        private$methods_ <- list(
           alloc = dust_cpu_seirhdage_alloc,
           run = dust_cpu_seirhdage_run,
           simulate = dust_cpu_seirhdage_simulate,
           run_adjoint = dust_cpu_seirhdage_run_adjoint,
           set_index = dust_cpu_seirhdage_set_index,
           n_state = dust_cpu_seirhdage_n_state,
           update_state = dust_cpu_seirhdage_update_state,
           state = dust_cpu_seirhdage_state,
           time = dust_cpu_seirhdage_time,
           reorder = dust_cpu_seirhdage_reorder,
           resample = dust_cpu_seirhdage_resample,
           rng_state = dust_cpu_seirhdage_rng_state,
           set_rng_state = dust_cpu_seirhdage_set_rng_state,
           set_n_threads = dust_cpu_seirhdage_set_n_threads,
           set_data = dust_cpu_seirhdage_set_data,
           compare_data = dust_cpu_seirhdage_compare_data,
           filter = dust_cpu_seirhdage_filter,
           set_stochastic_schedule = dust_cpu_seirhdage_set_stochastic_schedule,
           ode_statistics = dust_cpu_seirhdage_ode_statistics)
      } else {
        private$methods_ <- list(alloc = function(...) {
          stop("GPU support not enabled for this object")
        })
      }
      res <- private$methods_$alloc(pars, pars_multi, time, n_particles,
                        n_threads, seed, deterministic, gpu_config, ode_control)
      private$pars_ <- pars
      private$pars_multi_ <- pars_multi
      private$n_threads_ <- n_threads
      private$ptr_ <- res[[1L]]
      private$info_ <- res[[2L]]
      private$shape_ <- res[[3L]]
      private$gpu_config_ <- res[[4L]]
      private$ode_control_ <- res[[5L]]
      private$n_particles_ <- prod(private$shape_)
      if (pars_multi) {
        private$n_particles_each_ <- private$n_particles_ / length(pars)
      } else {
        private$n_particles_each_ <- private$n_particles_
      }
    },

    name = function() {
      "seirhdage"
    },

    param = function() {
      private$param_
    },

    run = function(time_end) {
      m <- private$methods_$run(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    simulate = function(time_end) {
      m <- private$methods_$simulate(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    run_adjoint = function() {
      res <- private$methods_$run_adjoint(private$ptr_)
      ## This approach may want to change, because it won't cope well
      ## with cases where are gradient is structured with respect to
      ## some parameters, but perhaps it's still a reasonable thing to
      ## do? While we have array-free models it's fine though.
      nms <- private$info_$adjoint
      if (!is.null(nms) && length(nms) == length(res$gradient)) {
        names(res$gradient) <- nms
      }
      res
    },

    set_index = function(index) {
      private$methods_$set_index(private$ptr_, index)
      private$index_ <- index
      invisible()
    },

    index = function() {
      private$index_
    },

    ode_control = function() {
      private$ode_control_
    },

    ode_statistics = function() {
      private$methods_$ode_statistics(private$ptr_)
    },

    n_threads = function() {
      private$n_threads_
    },

    n_state = function() {
      private$methods_$n_state(private$ptr_)
    },

    n_particles = function() {
      private$n_particles_
    },

    n_particles_each = function() {
      private$n_particles_each_
    },

    shape = function() {
      private$shape_
    },

    update_state = function(pars = NULL, state = NULL, time = NULL,
                            set_initial_state = NULL, index = NULL,
                            reset_step_size = NULL) {
      info <- private$methods_$update_state(private$ptr_, pars, state, time,
                                          set_initial_state, index,
                                          reset_step_size)
      if (!is.null(pars)) {
        private$info_ <- info
        private$pars_ <- pars
      }
      invisible()
    },

    state = function(index = NULL) {
      m <- private$methods_$state(private$ptr_, index)
      rownames(m) <- names(index)
      m
    },

    time = function() {
      private$methods_$time(private$ptr_)
    },

    set_stochastic_schedule = function(time) {
      private$methods_$set_stochastic_schedule(private$ptr_, time)
      invisible()
    },

    reorder = function(index) {
      storage.mode(index) <- "integer"
      private$methods_$reorder(private$ptr_, index)
      invisible()
    },

    resample = function(weights) {
      invisible(private$methods_$resample(private$ptr_, weights))
    },

    info = function() {
      private$info_
    },

    pars = function() {
      private$pars_
    },

    rng_state = function(first_only = FALSE, last_only = FALSE) {
      private$methods_$rng_state(private$ptr_, first_only, last_only)
    },

    set_rng_state = function(rng_state) {
      private$methods_$set_rng_state(private$ptr_, rng_state)
      invisible()
    },

    has_openmp = function() {
      dust_cpu_seirhdage_capabilities()[["openmp"]]
    },

    has_gpu_support = function(fake_gpu = FALSE) {
      if (fake_gpu) {
        FALSE
      } else {
        dust_cpu_seirhdage_capabilities()[["gpu"]]
      }
    },

    has_compare = function() {
      dust_cpu_seirhdage_capabilities()[["compare"]]
    },

    real_size = function() {
      dust_cpu_seirhdage_capabilities()[["real_size"]]
    },

    time_type = function() {
      dust_cpu_seirhdage_capabilities()[["time_type"]]
    },

    rng_algorithm = function() {
      dust_cpu_seirhdage_capabilities()[["rng_algorithm"]]
    },

    uses_gpu = function(fake_gpu = FALSE) {
      real_gpu <- private$gpu_config_$real_gpu
      !is.null(real_gpu) && (fake_gpu || real_gpu)
    },

    n_pars = function() {
      if (private$pars_multi_) length(private$pars_) else 0L
    },

    set_n_threads = function(n_threads) {
      prev <- private$n_threads_
      private$methods_$set_n_threads(private$ptr_, n_threads)
      private$n_threads_ <- n_threads
      invisible(prev)
    },

    set_data = function(data, shared = FALSE) {
      private$methods_$set_data(private$ptr_, data, shared)
    },

    compare_data = function() {
      private$methods_$compare_data(private$ptr_)
    },

    filter = function(time_end = NULL, save_trajectories = FALSE,
                      time_snapshot = NULL, min_log_likelihood = NULL) {
      private$methods_$filter(private$ptr_, time_end, save_trajectories,
                              time_snapshot, min_log_likelihood)
    },

    gpu_info = function() {
      ret <- dust_seirhdage_gpu_info()
      ret$devices <- as.data.frame(ret$devices, stringsAsFactors = FALSE)
      parent <- parent.env(environment())
      if (ret$has_cuda && exists("private", parent, inherits = FALSE)) {
        ret$config <- private$gpu_config_
      }
      ret
    }
  ))
class(seirhdage) <- c("dust_generator", class(seirhdage))
seirhdagevax <- R6::R6Class(
  "dust",
  cloneable = FALSE,

  private = list(
    pars_ = NULL,
    pars_multi_ = NULL,
    index_ = NULL,
    info_ = NULL,
    n_threads_ = NULL,
    n_particles_ = NULL,
    n_particles_each_ = NULL,
    shape_ = NULL,
    ptr_ = NULL,
    gpu_config_ = NULL,
    ode_control_ = NULL,
    methods_ = NULL,
    param_ = list(dt = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     index_dose = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     index_dose_inverse = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     m = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     n_age = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_doses = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_vax = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     p_C = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_D = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_G = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_H = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     rel_infectivity = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     rel_susceptibility = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     seed_step_start = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     seed_value = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     vaccine_dose_step = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     vaccine_progression_rate_base = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     beta = list(has_default = TRUE, default_value = 0.03, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_A = list(has_default = TRUE, default_value = 0.2, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_C = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_E = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_G = list(has_default = TRUE, default_value = list("/", 1L, 3L), rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_H = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_P = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     seed_age = list(has_default = TRUE, default_value = 4L, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     theta_A = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     vaccine_catchup_fraction = list(has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)),
    reload_ = NULL
  ),

  public = list(
    initialize = function(pars, time, n_particles, n_threads = 1L,
                          seed = NULL, pars_multi = FALSE,
                          deterministic = FALSE,
                          gpu_config = NULL, ode_control = NULL) {
      if (is.null(gpu_config)) {
        private$methods_ <- list(
           alloc = dust_cpu_seirhdagevax_alloc,
           run = dust_cpu_seirhdagevax_run,
           simulate = dust_cpu_seirhdagevax_simulate,
           run_adjoint = dust_cpu_seirhdagevax_run_adjoint,
           set_index = dust_cpu_seirhdagevax_set_index,
           n_state = dust_cpu_seirhdagevax_n_state,
           update_state = dust_cpu_seirhdagevax_update_state,
           state = dust_cpu_seirhdagevax_state,
           time = dust_cpu_seirhdagevax_time,
           reorder = dust_cpu_seirhdagevax_reorder,
           resample = dust_cpu_seirhdagevax_resample,
           rng_state = dust_cpu_seirhdagevax_rng_state,
           set_rng_state = dust_cpu_seirhdagevax_set_rng_state,
           set_n_threads = dust_cpu_seirhdagevax_set_n_threads,
           set_data = dust_cpu_seirhdagevax_set_data,
           compare_data = dust_cpu_seirhdagevax_compare_data,
           filter = dust_cpu_seirhdagevax_filter,
           set_stochastic_schedule = dust_cpu_seirhdagevax_set_stochastic_schedule,
           ode_statistics = dust_cpu_seirhdagevax_ode_statistics)
      } else {
        private$methods_ <- list(alloc = function(...) {
          stop("GPU support not enabled for this object")
        })
      }
      res <- private$methods_$alloc(pars, pars_multi, time, n_particles,
                        n_threads, seed, deterministic, gpu_config, ode_control)
      private$pars_ <- pars
      private$pars_multi_ <- pars_multi
      private$n_threads_ <- n_threads
      private$ptr_ <- res[[1L]]
      private$info_ <- res[[2L]]
      private$shape_ <- res[[3L]]
      private$gpu_config_ <- res[[4L]]
      private$ode_control_ <- res[[5L]]
      private$n_particles_ <- prod(private$shape_)
      if (pars_multi) {
        private$n_particles_each_ <- private$n_particles_ / length(pars)
      } else {
        private$n_particles_each_ <- private$n_particles_
      }
    },

    name = function() {
      "seirhdagevax"
    },

    param = function() {
      private$param_
    },

    run = function(time_end) {
      m <- private$methods_$run(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    simulate = function(time_end) {
      m <- private$methods_$simulate(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    run_adjoint = function() {
      res <- private$methods_$run_adjoint(private$ptr_)
      ## This approach may want to change, because it won't cope well
      ## with cases where are gradient is structured with respect to
      ## some parameters, but perhaps it's still a reasonable thing to
      ## do? While we have array-free models it's fine though.
      nms <- private$info_$adjoint
      if (!is.null(nms) && length(nms) == length(res$gradient)) {
        names(res$gradient) <- nms
      }
      res
    },

    set_index = function(index) {
      private$methods_$set_index(private$ptr_, index)
      private$index_ <- index
      invisible()
    },

    index = function() {
      private$index_
    },

    ode_control = function() {
      private$ode_control_
    },

    ode_statistics = function() {
      private$methods_$ode_statistics(private$ptr_)
    },

    n_threads = function() {
      private$n_threads_
    },

    n_state = function() {
      private$methods_$n_state(private$ptr_)
    },

    n_particles = function() {
      private$n_particles_
    },

    n_particles_each = function() {
      private$n_particles_each_
    },

    shape = function() {
      private$shape_
    },

    update_state = function(pars = NULL, state = NULL, time = NULL,
                            set_initial_state = NULL, index = NULL,
                            reset_step_size = NULL) {
      info <- private$methods_$update_state(private$ptr_, pars, state, time,
                                          set_initial_state, index,
                                          reset_step_size)
      if (!is.null(pars)) {
        private$info_ <- info
        private$pars_ <- pars
      }
      invisible()
    },

    state = function(index = NULL) {
      m <- private$methods_$state(private$ptr_, index)
      rownames(m) <- names(index)
      m
    },

    time = function() {
      private$methods_$time(private$ptr_)
    },

    set_stochastic_schedule = function(time) {
      private$methods_$set_stochastic_schedule(private$ptr_, time)
      invisible()
    },

    reorder = function(index) {
      storage.mode(index) <- "integer"
      private$methods_$reorder(private$ptr_, index)
      invisible()
    },

    resample = function(weights) {
      invisible(private$methods_$resample(private$ptr_, weights))
    },

    info = function() {
      private$info_
    },

    pars = function() {
      private$pars_
    },

    rng_state = function(first_only = FALSE, last_only = FALSE) {
      private$methods_$rng_state(private$ptr_, first_only, last_only)
    },

    set_rng_state = function(rng_state) {
      private$methods_$set_rng_state(private$ptr_, rng_state)
      invisible()
    },

    has_openmp = function() {
      dust_cpu_seirhdagevax_capabilities()[["openmp"]]
    },

    has_gpu_support = function(fake_gpu = FALSE) {
      if (fake_gpu) {
        FALSE
      } else {
        dust_cpu_seirhdagevax_capabilities()[["gpu"]]
      }
    },

    has_compare = function() {
      dust_cpu_seirhdagevax_capabilities()[["compare"]]
    },

    real_size = function() {
      dust_cpu_seirhdagevax_capabilities()[["real_size"]]
    },

    time_type = function() {
      dust_cpu_seirhdagevax_capabilities()[["time_type"]]
    },

    rng_algorithm = function() {
      dust_cpu_seirhdagevax_capabilities()[["rng_algorithm"]]
    },

    uses_gpu = function(fake_gpu = FALSE) {
      real_gpu <- private$gpu_config_$real_gpu
      !is.null(real_gpu) && (fake_gpu || real_gpu)
    },

    n_pars = function() {
      if (private$pars_multi_) length(private$pars_) else 0L
    },

    set_n_threads = function(n_threads) {
      prev <- private$n_threads_
      private$methods_$set_n_threads(private$ptr_, n_threads)
      private$n_threads_ <- n_threads
      invisible(prev)
    },

    set_data = function(data, shared = FALSE) {
      private$methods_$set_data(private$ptr_, data, shared)
    },

    compare_data = function() {
      private$methods_$compare_data(private$ptr_)
    },

    filter = function(time_end = NULL, save_trajectories = FALSE,
                      time_snapshot = NULL, min_log_likelihood = NULL) {
      private$methods_$filter(private$ptr_, time_end, save_trajectories,
                              time_snapshot, min_log_likelihood)
    },

    gpu_info = function() {
      ret <- dust_seirhdagevax_gpu_info()
      ret$devices <- as.data.frame(ret$devices, stringsAsFactors = FALSE)
      parent <- parent.env(environment())
      if (ret$has_cuda && exists("private", parent, inherits = FALSE)) {
        ret$config <- private$gpu_config_
      }
      ret
    }
  ))
class(seirhdagevax) <- c("dust_generator", class(seirhdagevax))
seirhdagevaxmultistrain <- R6::R6Class(
  "dust",
  cloneable = FALSE,

  private = list(
    pars_ = NULL,
    pars_multi_ = NULL,
    index_ = NULL,
    info_ = NULL,
    n_threads_ = NULL,
    n_particles_ = NULL,
    n_particles_each_ = NULL,
    shape_ = NULL,
    ptr_ = NULL,
    gpu_config_ = NULL,
    ode_control_ = NULL,
    methods_ = NULL,
    param_ = list(cross_immunity = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     dt = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     index_dose = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     index_dose_inverse = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     m = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     n_age = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_doses = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_strains = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_vax = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     p_C = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_D = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_G = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_H = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     rel_infectivity = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_p_death = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_p_hosp_if_sympt = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_p_sympt = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_susceptibility = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     seed_step_start = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     seed_value = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_rel_p_death = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_rel_p_hosp_if_sympt = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_rel_p_sympt = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_seed_step_start = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     strain_seed_value = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_transmission = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     vaccine_dose_step = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     vaccine_progression_rate_base = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     waning_rate = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     beta = list(has_default = TRUE, default_value = 0.03, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_A = list(has_default = TRUE, default_value = 0.2, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_C = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_E = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_G = list(has_default = TRUE, default_value = list("/", 1L, 3L), rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_H = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_P = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     seed_age = list(has_default = TRUE, default_value = 4L, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     theta_A = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     vaccine_catchup_fraction = list(has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)),
    reload_ = NULL
  ),

  public = list(
    initialize = function(pars, time, n_particles, n_threads = 1L,
                          seed = NULL, pars_multi = FALSE,
                          deterministic = FALSE,
                          gpu_config = NULL, ode_control = NULL) {
      if (is.null(gpu_config)) {
        private$methods_ <- list(
           alloc = dust_cpu_seirhdagevaxmultistrain_alloc,
           run = dust_cpu_seirhdagevaxmultistrain_run,
           simulate = dust_cpu_seirhdagevaxmultistrain_simulate,
           run_adjoint = dust_cpu_seirhdagevaxmultistrain_run_adjoint,
           set_index = dust_cpu_seirhdagevaxmultistrain_set_index,
           n_state = dust_cpu_seirhdagevaxmultistrain_n_state,
           update_state = dust_cpu_seirhdagevaxmultistrain_update_state,
           state = dust_cpu_seirhdagevaxmultistrain_state,
           time = dust_cpu_seirhdagevaxmultistrain_time,
           reorder = dust_cpu_seirhdagevaxmultistrain_reorder,
           resample = dust_cpu_seirhdagevaxmultistrain_resample,
           rng_state = dust_cpu_seirhdagevaxmultistrain_rng_state,
           set_rng_state = dust_cpu_seirhdagevaxmultistrain_set_rng_state,
           set_n_threads = dust_cpu_seirhdagevaxmultistrain_set_n_threads,
           set_data = dust_cpu_seirhdagevaxmultistrain_set_data,
           compare_data = dust_cpu_seirhdagevaxmultistrain_compare_data,
           filter = dust_cpu_seirhdagevaxmultistrain_filter,
           set_stochastic_schedule = dust_cpu_seirhdagevaxmultistrain_set_stochastic_schedule,
           ode_statistics = dust_cpu_seirhdagevaxmultistrain_ode_statistics)
      } else {
        private$methods_ <- list(alloc = function(...) {
          stop("GPU support not enabled for this object")
        })
      }
      res <- private$methods_$alloc(pars, pars_multi, time, n_particles,
                        n_threads, seed, deterministic, gpu_config, ode_control)
      private$pars_ <- pars
      private$pars_multi_ <- pars_multi
      private$n_threads_ <- n_threads
      private$ptr_ <- res[[1L]]
      private$info_ <- res[[2L]]
      private$shape_ <- res[[3L]]
      private$gpu_config_ <- res[[4L]]
      private$ode_control_ <- res[[5L]]
      private$n_particles_ <- prod(private$shape_)
      if (pars_multi) {
        private$n_particles_each_ <- private$n_particles_ / length(pars)
      } else {
        private$n_particles_each_ <- private$n_particles_
      }
    },

    name = function() {
      "seirhdagevaxmultistrain"
    },

    param = function() {
      private$param_
    },

    run = function(time_end) {
      m <- private$methods_$run(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    simulate = function(time_end) {
      m <- private$methods_$simulate(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    run_adjoint = function() {
      res <- private$methods_$run_adjoint(private$ptr_)
      ## This approach may want to change, because it won't cope well
      ## with cases where are gradient is structured with respect to
      ## some parameters, but perhaps it's still a reasonable thing to
      ## do? While we have array-free models it's fine though.
      nms <- private$info_$adjoint
      if (!is.null(nms) && length(nms) == length(res$gradient)) {
        names(res$gradient) <- nms
      }
      res
    },

    set_index = function(index) {
      private$methods_$set_index(private$ptr_, index)
      private$index_ <- index
      invisible()
    },

    index = function() {
      private$index_
    },

    ode_control = function() {
      private$ode_control_
    },

    ode_statistics = function() {
      private$methods_$ode_statistics(private$ptr_)
    },

    n_threads = function() {
      private$n_threads_
    },

    n_state = function() {
      private$methods_$n_state(private$ptr_)
    },

    n_particles = function() {
      private$n_particles_
    },

    n_particles_each = function() {
      private$n_particles_each_
    },

    shape = function() {
      private$shape_
    },

    update_state = function(pars = NULL, state = NULL, time = NULL,
                            set_initial_state = NULL, index = NULL,
                            reset_step_size = NULL) {
      info <- private$methods_$update_state(private$ptr_, pars, state, time,
                                          set_initial_state, index,
                                          reset_step_size)
      if (!is.null(pars)) {
        private$info_ <- info
        private$pars_ <- pars
      }
      invisible()
    },

    state = function(index = NULL) {
      m <- private$methods_$state(private$ptr_, index)
      rownames(m) <- names(index)
      m
    },

    time = function() {
      private$methods_$time(private$ptr_)
    },

    set_stochastic_schedule = function(time) {
      private$methods_$set_stochastic_schedule(private$ptr_, time)
      invisible()
    },

    reorder = function(index) {
      storage.mode(index) <- "integer"
      private$methods_$reorder(private$ptr_, index)
      invisible()
    },

    resample = function(weights) {
      invisible(private$methods_$resample(private$ptr_, weights))
    },

    info = function() {
      private$info_
    },

    pars = function() {
      private$pars_
    },

    rng_state = function(first_only = FALSE, last_only = FALSE) {
      private$methods_$rng_state(private$ptr_, first_only, last_only)
    },

    set_rng_state = function(rng_state) {
      private$methods_$set_rng_state(private$ptr_, rng_state)
      invisible()
    },

    has_openmp = function() {
      dust_cpu_seirhdagevaxmultistrain_capabilities()[["openmp"]]
    },

    has_gpu_support = function(fake_gpu = FALSE) {
      if (fake_gpu) {
        FALSE
      } else {
        dust_cpu_seirhdagevaxmultistrain_capabilities()[["gpu"]]
      }
    },

    has_compare = function() {
      dust_cpu_seirhdagevaxmultistrain_capabilities()[["compare"]]
    },

    real_size = function() {
      dust_cpu_seirhdagevaxmultistrain_capabilities()[["real_size"]]
    },

    time_type = function() {
      dust_cpu_seirhdagevaxmultistrain_capabilities()[["time_type"]]
    },

    rng_algorithm = function() {
      dust_cpu_seirhdagevaxmultistrain_capabilities()[["rng_algorithm"]]
    },

    uses_gpu = function(fake_gpu = FALSE) {
      real_gpu <- private$gpu_config_$real_gpu
      !is.null(real_gpu) && (fake_gpu || real_gpu)
    },

    n_pars = function() {
      if (private$pars_multi_) length(private$pars_) else 0L
    },

    set_n_threads = function(n_threads) {
      prev <- private$n_threads_
      private$methods_$set_n_threads(private$ptr_, n_threads)
      private$n_threads_ <- n_threads
      invisible(prev)
    },

    set_data = function(data, shared = FALSE) {
      private$methods_$set_data(private$ptr_, data, shared)
    },

    compare_data = function() {
      private$methods_$compare_data(private$ptr_)
    },

    filter = function(time_end = NULL, save_trajectories = FALSE,
                      time_snapshot = NULL, min_log_likelihood = NULL) {
      private$methods_$filter(private$ptr_, time_end, save_trajectories,
                              time_snapshot, min_log_likelihood)
    },

    gpu_info = function() {
      ret <- dust_seirhdagevaxmultistrain_gpu_info()
      ret$devices <- as.data.frame(ret$devices, stringsAsFactors = FALSE)
      parent <- parent.env(environment())
      if (ret$has_cuda && exists("private", parent, inherits = FALSE)) {
        ret$config <- private$gpu_config_
      }
      ret
    }
  ))
class(seirhdagevaxmultistrain) <- c("dust_generator", class(seirhdagevaxmultistrain))
seirhdagevaxmultistrainsero <- R6::R6Class(
  "dust",
  cloneable = FALSE,

  private = list(
    pars_ = NULL,
    pars_multi_ = NULL,
    index_ = NULL,
    info_ = NULL,
    n_threads_ = NULL,
    n_particles_ = NULL,
    n_particles_each_ = NULL,
    shape_ = NULL,
    ptr_ = NULL,
    gpu_config_ = NULL,
    ode_control_ = NULL,
    methods_ = NULL,
    param_ = list(cross_immunity = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     dt = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     index_dose = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     index_dose_inverse = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     m = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     n_age = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_doses = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_strains = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_vax = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     p_C = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_D = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_G = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_H = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     rel_infectivity = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_p_death = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_p_hosp_if_sympt = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_p_sympt = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_susceptibility = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     seed_step_start = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     seed_value = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_rel_p_death = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_rel_p_hosp_if_sympt = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_rel_p_sympt = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_seed_step_start = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     strain_seed_value = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_transmission = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     vaccine_dose_step = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     vaccine_progression_rate_base = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     waning_rate = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     beta = list(has_default = TRUE, default_value = 0.03, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_A = list(has_default = TRUE, default_value = 0.2, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_C = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_E = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_G = list(has_default = TRUE, default_value = list("/", 1L, 3L), rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_H = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_P = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_P_1 = list(has_default = TRUE, default_value = list("/", 1L, 200L), rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_pre_1 = list(has_default = TRUE, default_value = list("/", 1L, 13L), rank = 0, min = -Inf, max = Inf, integer = FALSE),
     p_P_1 = list(has_default = TRUE, default_value = 0.85, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     seed_age = list(has_default = TRUE, default_value = 4L, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     theta_A = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     vaccine_catchup_fraction = list(has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)),
    reload_ = NULL
  ),

  public = list(
    initialize = function(pars, time, n_particles, n_threads = 1L,
                          seed = NULL, pars_multi = FALSE,
                          deterministic = FALSE,
                          gpu_config = NULL, ode_control = NULL) {
      if (is.null(gpu_config)) {
        private$methods_ <- list(
           alloc = dust_cpu_seirhdagevaxmultistrainsero_alloc,
           run = dust_cpu_seirhdagevaxmultistrainsero_run,
           simulate = dust_cpu_seirhdagevaxmultistrainsero_simulate,
           run_adjoint = dust_cpu_seirhdagevaxmultistrainsero_run_adjoint,
           set_index = dust_cpu_seirhdagevaxmultistrainsero_set_index,
           n_state = dust_cpu_seirhdagevaxmultistrainsero_n_state,
           update_state = dust_cpu_seirhdagevaxmultistrainsero_update_state,
           state = dust_cpu_seirhdagevaxmultistrainsero_state,
           time = dust_cpu_seirhdagevaxmultistrainsero_time,
           reorder = dust_cpu_seirhdagevaxmultistrainsero_reorder,
           resample = dust_cpu_seirhdagevaxmultistrainsero_resample,
           rng_state = dust_cpu_seirhdagevaxmultistrainsero_rng_state,
           set_rng_state = dust_cpu_seirhdagevaxmultistrainsero_set_rng_state,
           set_n_threads = dust_cpu_seirhdagevaxmultistrainsero_set_n_threads,
           set_data = dust_cpu_seirhdagevaxmultistrainsero_set_data,
           compare_data = dust_cpu_seirhdagevaxmultistrainsero_compare_data,
           filter = dust_cpu_seirhdagevaxmultistrainsero_filter,
           set_stochastic_schedule = dust_cpu_seirhdagevaxmultistrainsero_set_stochastic_schedule,
           ode_statistics = dust_cpu_seirhdagevaxmultistrainsero_ode_statistics)
      } else {
        private$methods_ <- list(alloc = function(...) {
          stop("GPU support not enabled for this object")
        })
      }
      res <- private$methods_$alloc(pars, pars_multi, time, n_particles,
                        n_threads, seed, deterministic, gpu_config, ode_control)
      private$pars_ <- pars
      private$pars_multi_ <- pars_multi
      private$n_threads_ <- n_threads
      private$ptr_ <- res[[1L]]
      private$info_ <- res[[2L]]
      private$shape_ <- res[[3L]]
      private$gpu_config_ <- res[[4L]]
      private$ode_control_ <- res[[5L]]
      private$n_particles_ <- prod(private$shape_)
      if (pars_multi) {
        private$n_particles_each_ <- private$n_particles_ / length(pars)
      } else {
        private$n_particles_each_ <- private$n_particles_
      }
    },

    name = function() {
      "seirhdagevaxmultistrainsero"
    },

    param = function() {
      private$param_
    },

    run = function(time_end) {
      m <- private$methods_$run(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    simulate = function(time_end) {
      m <- private$methods_$simulate(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    run_adjoint = function() {
      res <- private$methods_$run_adjoint(private$ptr_)
      ## This approach may want to change, because it won't cope well
      ## with cases where are gradient is structured with respect to
      ## some parameters, but perhaps it's still a reasonable thing to
      ## do? While we have array-free models it's fine though.
      nms <- private$info_$adjoint
      if (!is.null(nms) && length(nms) == length(res$gradient)) {
        names(res$gradient) <- nms
      }
      res
    },

    set_index = function(index) {
      private$methods_$set_index(private$ptr_, index)
      private$index_ <- index
      invisible()
    },

    index = function() {
      private$index_
    },

    ode_control = function() {
      private$ode_control_
    },

    ode_statistics = function() {
      private$methods_$ode_statistics(private$ptr_)
    },

    n_threads = function() {
      private$n_threads_
    },

    n_state = function() {
      private$methods_$n_state(private$ptr_)
    },

    n_particles = function() {
      private$n_particles_
    },

    n_particles_each = function() {
      private$n_particles_each_
    },

    shape = function() {
      private$shape_
    },

    update_state = function(pars = NULL, state = NULL, time = NULL,
                            set_initial_state = NULL, index = NULL,
                            reset_step_size = NULL) {
      info <- private$methods_$update_state(private$ptr_, pars, state, time,
                                          set_initial_state, index,
                                          reset_step_size)
      if (!is.null(pars)) {
        private$info_ <- info
        private$pars_ <- pars
      }
      invisible()
    },

    state = function(index = NULL) {
      m <- private$methods_$state(private$ptr_, index)
      rownames(m) <- names(index)
      m
    },

    time = function() {
      private$methods_$time(private$ptr_)
    },

    set_stochastic_schedule = function(time) {
      private$methods_$set_stochastic_schedule(private$ptr_, time)
      invisible()
    },

    reorder = function(index) {
      storage.mode(index) <- "integer"
      private$methods_$reorder(private$ptr_, index)
      invisible()
    },

    resample = function(weights) {
      invisible(private$methods_$resample(private$ptr_, weights))
    },

    info = function() {
      private$info_
    },

    pars = function() {
      private$pars_
    },

    rng_state = function(first_only = FALSE, last_only = FALSE) {
      private$methods_$rng_state(private$ptr_, first_only, last_only)
    },

    set_rng_state = function(rng_state) {
      private$methods_$set_rng_state(private$ptr_, rng_state)
      invisible()
    },

    has_openmp = function() {
      dust_cpu_seirhdagevaxmultistrainsero_capabilities()[["openmp"]]
    },

    has_gpu_support = function(fake_gpu = FALSE) {
      if (fake_gpu) {
        FALSE
      } else {
        dust_cpu_seirhdagevaxmultistrainsero_capabilities()[["gpu"]]
      }
    },

    has_compare = function() {
      dust_cpu_seirhdagevaxmultistrainsero_capabilities()[["compare"]]
    },

    real_size = function() {
      dust_cpu_seirhdagevaxmultistrainsero_capabilities()[["real_size"]]
    },

    time_type = function() {
      dust_cpu_seirhdagevaxmultistrainsero_capabilities()[["time_type"]]
    },

    rng_algorithm = function() {
      dust_cpu_seirhdagevaxmultistrainsero_capabilities()[["rng_algorithm"]]
    },

    uses_gpu = function(fake_gpu = FALSE) {
      real_gpu <- private$gpu_config_$real_gpu
      !is.null(real_gpu) && (fake_gpu || real_gpu)
    },

    n_pars = function() {
      if (private$pars_multi_) length(private$pars_) else 0L
    },

    set_n_threads = function(n_threads) {
      prev <- private$n_threads_
      private$methods_$set_n_threads(private$ptr_, n_threads)
      private$n_threads_ <- n_threads
      invisible(prev)
    },

    set_data = function(data, shared = FALSE) {
      private$methods_$set_data(private$ptr_, data, shared)
    },

    compare_data = function() {
      private$methods_$compare_data(private$ptr_)
    },

    filter = function(time_end = NULL, save_trajectories = FALSE,
                      time_snapshot = NULL, min_log_likelihood = NULL) {
      private$methods_$filter(private$ptr_, time_end, save_trajectories,
                              time_snapshot, min_log_likelihood)
    },

    gpu_info = function() {
      ret <- dust_seirhdagevaxmultistrainsero_gpu_info()
      ret$devices <- as.data.frame(ret$devices, stringsAsFactors = FALSE)
      parent <- parent.env(environment())
      if (ret$has_cuda && exists("private", parent, inherits = FALSE)) {
        ret$config <- private$gpu_config_
      }
      ret
    }
  ))
class(seirhdagevaxmultistrainsero) <- c("dust_generator", class(seirhdagevaxmultistrainsero))
seirhdagevaxmultistrainserotimedepbeta <- R6::R6Class(
  "dust",
  cloneable = FALSE,

  private = list(
    pars_ = NULL,
    pars_multi_ = NULL,
    index_ = NULL,
    info_ = NULL,
    n_threads_ = NULL,
    n_particles_ = NULL,
    n_particles_each_ = NULL,
    shape_ = NULL,
    ptr_ = NULL,
    gpu_config_ = NULL,
    ode_control_ = NULL,
    methods_ = NULL,
    param_ = list(beta_step = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     cross_immunity = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     dt = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     index_dose = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     index_dose_inverse = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     m = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     n_age = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_doses = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_strains = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     n_vax = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     p_C = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_D = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_G = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     p_H = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     rel_infectivity = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_p_death = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_p_hosp_if_sympt = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_p_sympt = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     rel_susceptibility = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     seed_step_start = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     seed_value = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_rel_p_death = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_rel_p_hosp_if_sympt = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_rel_p_sympt = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_seed_step_start = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     strain_seed_value = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     strain_transmission = list(has_default = FALSE, default_value = NULL, rank = 1, min = -Inf, max = Inf, integer = FALSE),
     vaccine_dose_step = list(has_default = FALSE, default_value = NULL, rank = 3, min = -Inf, max = Inf, integer = FALSE),
     vaccine_progression_rate_base = list(has_default = FALSE, default_value = NULL, rank = 2, min = -Inf, max = Inf, integer = FALSE),
     waning_rate = list(has_default = FALSE, default_value = NULL, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_A = list(has_default = TRUE, default_value = 0.2, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_C = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_E = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_G = list(has_default = TRUE, default_value = list("/", 1L, 3L), rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_H = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_P = list(has_default = TRUE, default_value = 0.4, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_P_1 = list(has_default = TRUE, default_value = list("/", 1L, 200L), rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma_pre_1 = list(has_default = TRUE, default_value = list("/", 1L, 13L), rank = 0, min = -Inf, max = Inf, integer = FALSE),
     p_P_1 = list(has_default = TRUE, default_value = 0.85, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     seed_age = list(has_default = TRUE, default_value = 4L, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     theta_A = list(has_default = TRUE, default_value = 0.5, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     vaccine_catchup_fraction = list(has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE)),
    reload_ = NULL
  ),

  public = list(
    initialize = function(pars, time, n_particles, n_threads = 1L,
                          seed = NULL, pars_multi = FALSE,
                          deterministic = FALSE,
                          gpu_config = NULL, ode_control = NULL) {
      if (is.null(gpu_config)) {
        private$methods_ <- list(
           alloc = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_alloc,
           run = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_run,
           simulate = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_simulate,
           run_adjoint = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_run_adjoint,
           set_index = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_set_index,
           n_state = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_n_state,
           update_state = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_update_state,
           state = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_state,
           time = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_time,
           reorder = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_reorder,
           resample = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_resample,
           rng_state = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_rng_state,
           set_rng_state = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_set_rng_state,
           set_n_threads = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_set_n_threads,
           set_data = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_set_data,
           compare_data = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_compare_data,
           filter = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_filter,
           set_stochastic_schedule = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_set_stochastic_schedule,
           ode_statistics = dust_cpu_seirhdagevaxmultistrainserotimedepbeta_ode_statistics)
      } else {
        private$methods_ <- list(alloc = function(...) {
          stop("GPU support not enabled for this object")
        })
      }
      res <- private$methods_$alloc(pars, pars_multi, time, n_particles,
                        n_threads, seed, deterministic, gpu_config, ode_control)
      private$pars_ <- pars
      private$pars_multi_ <- pars_multi
      private$n_threads_ <- n_threads
      private$ptr_ <- res[[1L]]
      private$info_ <- res[[2L]]
      private$shape_ <- res[[3L]]
      private$gpu_config_ <- res[[4L]]
      private$ode_control_ <- res[[5L]]
      private$n_particles_ <- prod(private$shape_)
      if (pars_multi) {
        private$n_particles_each_ <- private$n_particles_ / length(pars)
      } else {
        private$n_particles_each_ <- private$n_particles_
      }
    },

    name = function() {
      "seirhdagevaxmultistrainserotimedepbeta"
    },

    param = function() {
      private$param_
    },

    run = function(time_end) {
      m <- private$methods_$run(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    simulate = function(time_end) {
      m <- private$methods_$simulate(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    run_adjoint = function() {
      res <- private$methods_$run_adjoint(private$ptr_)
      ## This approach may want to change, because it won't cope well
      ## with cases where are gradient is structured with respect to
      ## some parameters, but perhaps it's still a reasonable thing to
      ## do? While we have array-free models it's fine though.
      nms <- private$info_$adjoint
      if (!is.null(nms) && length(nms) == length(res$gradient)) {
        names(res$gradient) <- nms
      }
      res
    },

    set_index = function(index) {
      private$methods_$set_index(private$ptr_, index)
      private$index_ <- index
      invisible()
    },

    index = function() {
      private$index_
    },

    ode_control = function() {
      private$ode_control_
    },

    ode_statistics = function() {
      private$methods_$ode_statistics(private$ptr_)
    },

    n_threads = function() {
      private$n_threads_
    },

    n_state = function() {
      private$methods_$n_state(private$ptr_)
    },

    n_particles = function() {
      private$n_particles_
    },

    n_particles_each = function() {
      private$n_particles_each_
    },

    shape = function() {
      private$shape_
    },

    update_state = function(pars = NULL, state = NULL, time = NULL,
                            set_initial_state = NULL, index = NULL,
                            reset_step_size = NULL) {
      info <- private$methods_$update_state(private$ptr_, pars, state, time,
                                          set_initial_state, index,
                                          reset_step_size)
      if (!is.null(pars)) {
        private$info_ <- info
        private$pars_ <- pars
      }
      invisible()
    },

    state = function(index = NULL) {
      m <- private$methods_$state(private$ptr_, index)
      rownames(m) <- names(index)
      m
    },

    time = function() {
      private$methods_$time(private$ptr_)
    },

    set_stochastic_schedule = function(time) {
      private$methods_$set_stochastic_schedule(private$ptr_, time)
      invisible()
    },

    reorder = function(index) {
      storage.mode(index) <- "integer"
      private$methods_$reorder(private$ptr_, index)
      invisible()
    },

    resample = function(weights) {
      invisible(private$methods_$resample(private$ptr_, weights))
    },

    info = function() {
      private$info_
    },

    pars = function() {
      private$pars_
    },

    rng_state = function(first_only = FALSE, last_only = FALSE) {
      private$methods_$rng_state(private$ptr_, first_only, last_only)
    },

    set_rng_state = function(rng_state) {
      private$methods_$set_rng_state(private$ptr_, rng_state)
      invisible()
    },

    has_openmp = function() {
      dust_cpu_seirhdagevaxmultistrainserotimedepbeta_capabilities()[["openmp"]]
    },

    has_gpu_support = function(fake_gpu = FALSE) {
      if (fake_gpu) {
        FALSE
      } else {
        dust_cpu_seirhdagevaxmultistrainserotimedepbeta_capabilities()[["gpu"]]
      }
    },

    has_compare = function() {
      dust_cpu_seirhdagevaxmultistrainserotimedepbeta_capabilities()[["compare"]]
    },

    real_size = function() {
      dust_cpu_seirhdagevaxmultistrainserotimedepbeta_capabilities()[["real_size"]]
    },

    time_type = function() {
      dust_cpu_seirhdagevaxmultistrainserotimedepbeta_capabilities()[["time_type"]]
    },

    rng_algorithm = function() {
      dust_cpu_seirhdagevaxmultistrainserotimedepbeta_capabilities()[["rng_algorithm"]]
    },

    uses_gpu = function(fake_gpu = FALSE) {
      real_gpu <- private$gpu_config_$real_gpu
      !is.null(real_gpu) && (fake_gpu || real_gpu)
    },

    n_pars = function() {
      if (private$pars_multi_) length(private$pars_) else 0L
    },

    set_n_threads = function(n_threads) {
      prev <- private$n_threads_
      private$methods_$set_n_threads(private$ptr_, n_threads)
      private$n_threads_ <- n_threads
      invisible(prev)
    },

    set_data = function(data, shared = FALSE) {
      private$methods_$set_data(private$ptr_, data, shared)
    },

    compare_data = function() {
      private$methods_$compare_data(private$ptr_)
    },

    filter = function(time_end = NULL, save_trajectories = FALSE,
                      time_snapshot = NULL, min_log_likelihood = NULL) {
      private$methods_$filter(private$ptr_, time_end, save_trajectories,
                              time_snapshot, min_log_likelihood)
    },

    gpu_info = function() {
      ret <- dust_seirhdagevaxmultistrainserotimedepbeta_gpu_info()
      ret$devices <- as.data.frame(ret$devices, stringsAsFactors = FALSE)
      parent <- parent.env(environment())
      if (ret$has_cuda && exists("private", parent, inherits = FALSE)) {
        ret$config <- private$gpu_config_
      }
      ret
    }
  ))
class(seirhdagevaxmultistrainserotimedepbeta) <- c("dust_generator", class(seirhdagevaxmultistrainserotimedepbeta))
sir <- R6::R6Class(
  "dust",
  cloneable = FALSE,

  private = list(
    pars_ = NULL,
    pars_multi_ = NULL,
    index_ = NULL,
    info_ = NULL,
    n_threads_ = NULL,
    n_particles_ = NULL,
    n_particles_each_ = NULL,
    shape_ = NULL,
    ptr_ = NULL,
    gpu_config_ = NULL,
    ode_control_ = NULL,
    methods_ = NULL,
    param_ = list(beta = list(has_default = TRUE, default_value = 0.2, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     dt = list(has_default = TRUE, default_value = 1L, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     gamma = list(has_default = TRUE, default_value = 0.1, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     I_ini = list(has_default = TRUE, default_value = 10L, rank = 0, min = -Inf, max = Inf, integer = FALSE),
     S_ini = list(has_default = TRUE, default_value = 1000L, rank = 0, min = -Inf, max = Inf, integer = FALSE)),
    reload_ = NULL
  ),

  public = list(
    initialize = function(pars, time, n_particles, n_threads = 1L,
                          seed = NULL, pars_multi = FALSE,
                          deterministic = FALSE,
                          gpu_config = NULL, ode_control = NULL) {
      if (is.null(gpu_config)) {
        private$methods_ <- list(
           alloc = dust_cpu_sir_alloc,
           run = dust_cpu_sir_run,
           simulate = dust_cpu_sir_simulate,
           run_adjoint = dust_cpu_sir_run_adjoint,
           set_index = dust_cpu_sir_set_index,
           n_state = dust_cpu_sir_n_state,
           update_state = dust_cpu_sir_update_state,
           state = dust_cpu_sir_state,
           time = dust_cpu_sir_time,
           reorder = dust_cpu_sir_reorder,
           resample = dust_cpu_sir_resample,
           rng_state = dust_cpu_sir_rng_state,
           set_rng_state = dust_cpu_sir_set_rng_state,
           set_n_threads = dust_cpu_sir_set_n_threads,
           set_data = dust_cpu_sir_set_data,
           compare_data = dust_cpu_sir_compare_data,
           filter = dust_cpu_sir_filter,
           set_stochastic_schedule = dust_cpu_sir_set_stochastic_schedule,
           ode_statistics = dust_cpu_sir_ode_statistics)
      } else {
        private$methods_ <- list(alloc = function(...) {
          stop("GPU support not enabled for this object")
        })
      }
      res <- private$methods_$alloc(pars, pars_multi, time, n_particles,
                        n_threads, seed, deterministic, gpu_config, ode_control)
      private$pars_ <- pars
      private$pars_multi_ <- pars_multi
      private$n_threads_ <- n_threads
      private$ptr_ <- res[[1L]]
      private$info_ <- res[[2L]]
      private$shape_ <- res[[3L]]
      private$gpu_config_ <- res[[4L]]
      private$ode_control_ <- res[[5L]]
      private$n_particles_ <- prod(private$shape_)
      if (pars_multi) {
        private$n_particles_each_ <- private$n_particles_ / length(pars)
      } else {
        private$n_particles_each_ <- private$n_particles_
      }
    },

    name = function() {
      "sir"
    },

    param = function() {
      private$param_
    },

    run = function(time_end) {
      m <- private$methods_$run(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    simulate = function(time_end) {
      m <- private$methods_$simulate(private$ptr_, time_end)
      rownames(m) <- names(private$index_)
      m
    },

    run_adjoint = function() {
      res <- private$methods_$run_adjoint(private$ptr_)
      ## This approach may want to change, because it won't cope well
      ## with cases where are gradient is structured with respect to
      ## some parameters, but perhaps it's still a reasonable thing to
      ## do? While we have array-free models it's fine though.
      nms <- private$info_$adjoint
      if (!is.null(nms) && length(nms) == length(res$gradient)) {
        names(res$gradient) <- nms
      }
      res
    },

    set_index = function(index) {
      private$methods_$set_index(private$ptr_, index)
      private$index_ <- index
      invisible()
    },

    index = function() {
      private$index_
    },

    ode_control = function() {
      private$ode_control_
    },

    ode_statistics = function() {
      private$methods_$ode_statistics(private$ptr_)
    },

    n_threads = function() {
      private$n_threads_
    },

    n_state = function() {
      private$methods_$n_state(private$ptr_)
    },

    n_particles = function() {
      private$n_particles_
    },

    n_particles_each = function() {
      private$n_particles_each_
    },

    shape = function() {
      private$shape_
    },

    update_state = function(pars = NULL, state = NULL, time = NULL,
                            set_initial_state = NULL, index = NULL,
                            reset_step_size = NULL) {
      info <- private$methods_$update_state(private$ptr_, pars, state, time,
                                          set_initial_state, index,
                                          reset_step_size)
      if (!is.null(pars)) {
        private$info_ <- info
        private$pars_ <- pars
      }
      invisible()
    },

    state = function(index = NULL) {
      m <- private$methods_$state(private$ptr_, index)
      rownames(m) <- names(index)
      m
    },

    time = function() {
      private$methods_$time(private$ptr_)
    },

    set_stochastic_schedule = function(time) {
      private$methods_$set_stochastic_schedule(private$ptr_, time)
      invisible()
    },

    reorder = function(index) {
      storage.mode(index) <- "integer"
      private$methods_$reorder(private$ptr_, index)
      invisible()
    },

    resample = function(weights) {
      invisible(private$methods_$resample(private$ptr_, weights))
    },

    info = function() {
      private$info_
    },

    pars = function() {
      private$pars_
    },

    rng_state = function(first_only = FALSE, last_only = FALSE) {
      private$methods_$rng_state(private$ptr_, first_only, last_only)
    },

    set_rng_state = function(rng_state) {
      private$methods_$set_rng_state(private$ptr_, rng_state)
      invisible()
    },

    has_openmp = function() {
      dust_cpu_sir_capabilities()[["openmp"]]
    },

    has_gpu_support = function(fake_gpu = FALSE) {
      if (fake_gpu) {
        FALSE
      } else {
        dust_cpu_sir_capabilities()[["gpu"]]
      }
    },

    has_compare = function() {
      dust_cpu_sir_capabilities()[["compare"]]
    },

    real_size = function() {
      dust_cpu_sir_capabilities()[["real_size"]]
    },

    time_type = function() {
      dust_cpu_sir_capabilities()[["time_type"]]
    },

    rng_algorithm = function() {
      dust_cpu_sir_capabilities()[["rng_algorithm"]]
    },

    uses_gpu = function(fake_gpu = FALSE) {
      real_gpu <- private$gpu_config_$real_gpu
      !is.null(real_gpu) && (fake_gpu || real_gpu)
    },

    n_pars = function() {
      if (private$pars_multi_) length(private$pars_) else 0L
    },

    set_n_threads = function(n_threads) {
      prev <- private$n_threads_
      private$methods_$set_n_threads(private$ptr_, n_threads)
      private$n_threads_ <- n_threads
      invisible(prev)
    },

    set_data = function(data, shared = FALSE) {
      private$methods_$set_data(private$ptr_, data, shared)
    },

    compare_data = function() {
      private$methods_$compare_data(private$ptr_)
    },

    filter = function(time_end = NULL, save_trajectories = FALSE,
                      time_snapshot = NULL, min_log_likelihood = NULL) {
      private$methods_$filter(private$ptr_, time_end, save_trajectories,
                              time_snapshot, min_log_likelihood)
    },

    gpu_info = function() {
      ret <- dust_sir_gpu_info()
      ret$devices <- as.data.frame(ret$devices, stringsAsFactors = FALSE)
      parent <- parent.env(environment())
      if (ret$has_cuda && exists("private", parent, inherits = FALSE)) {
        ret$config <- private$gpu_config_
      }
      ret
    }
  ))
class(sir) <- c("dust_generator", class(sir))
## Generated by odin.dust (version 0.3.10) - do not edit
seir$set("public", "transform_variables", function(y) {
    info <- self$info()
    set_dim <- function(x, dimx) {
        if (length(dimx) > 1L) {
            dim(x) <- dimx
        }
        x
    }
    if (is.matrix(y)) {
        n <- ncol(y)
        Map(function(i, d) set_dim(y[i, , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else if (is.array(y)) {
        n <- dim(y)[2:3]
        Map(function(i, d) set_dim(y[i, , , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else {
        Map(function(i, d) set_dim(y[i], d), info$index, info$dim)
    }
})
seirdage$set("public", "transform_variables", function(y) {
    info <- self$info()
    set_dim <- function(x, dimx) {
        if (length(dimx) > 1L) {
            dim(x) <- dimx
        }
        x
    }
    if (is.matrix(y)) {
        n <- ncol(y)
        Map(function(i, d) set_dim(y[i, , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else if (is.array(y)) {
        n <- dim(y)[2:3]
        Map(function(i, d) set_dim(y[i, , , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else {
        Map(function(i, d) set_dim(y[i], d), info$index, info$dim)
    }
})
seirhdage$set("public", "transform_variables", function(y) {
    info <- self$info()
    set_dim <- function(x, dimx) {
        if (length(dimx) > 1L) {
            dim(x) <- dimx
        }
        x
    }
    if (is.matrix(y)) {
        n <- ncol(y)
        Map(function(i, d) set_dim(y[i, , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else if (is.array(y)) {
        n <- dim(y)[2:3]
        Map(function(i, d) set_dim(y[i, , , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else {
        Map(function(i, d) set_dim(y[i], d), info$index, info$dim)
    }
})
seirhdagevax$set("public", "transform_variables", function(y) {
    info <- self$info()
    set_dim <- function(x, dimx) {
        if (length(dimx) > 1L) {
            dim(x) <- dimx
        }
        x
    }
    if (is.matrix(y)) {
        n <- ncol(y)
        Map(function(i, d) set_dim(y[i, , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else if (is.array(y)) {
        n <- dim(y)[2:3]
        Map(function(i, d) set_dim(y[i, , , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else {
        Map(function(i, d) set_dim(y[i], d), info$index, info$dim)
    }
})
seirhdagevaxmultistrain$set("public", "transform_variables", function(y) {
    info <- self$info()
    set_dim <- function(x, dimx) {
        if (length(dimx) > 1L) {
            dim(x) <- dimx
        }
        x
    }
    if (is.matrix(y)) {
        n <- ncol(y)
        Map(function(i, d) set_dim(y[i, , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else if (is.array(y)) {
        n <- dim(y)[2:3]
        Map(function(i, d) set_dim(y[i, , , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else {
        Map(function(i, d) set_dim(y[i], d), info$index, info$dim)
    }
})
seirhdagevaxmultistrainsero$set("public", "transform_variables", function(y) {
    info <- self$info()
    set_dim <- function(x, dimx) {
        if (length(dimx) > 1L) {
            dim(x) <- dimx
        }
        x
    }
    if (is.matrix(y)) {
        n <- ncol(y)
        Map(function(i, d) set_dim(y[i, , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else if (is.array(y)) {
        n <- dim(y)[2:3]
        Map(function(i, d) set_dim(y[i, , , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else {
        Map(function(i, d) set_dim(y[i], d), info$index, info$dim)
    }
})
seirhdagevaxmultistrainserotimedepbeta$set("public", "transform_variables", function(y) {
    info <- self$info()
    set_dim <- function(x, dimx) {
        if (length(dimx) > 1L) {
            dim(x) <- dimx
        }
        x
    }
    if (is.matrix(y)) {
        n <- ncol(y)
        Map(function(i, d) set_dim(y[i, , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else if (is.array(y)) {
        n <- dim(y)[2:3]
        Map(function(i, d) set_dim(y[i, , , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else {
        Map(function(i, d) set_dim(y[i], d), info$index, info$dim)
    }
})
sir$set("public", "transform_variables", function(y) {
    info <- self$info()
    set_dim <- function(x, dimx) {
        if (length(dimx) > 1L) {
            dim(x) <- dimx
        }
        x
    }
    if (is.matrix(y)) {
        n <- ncol(y)
        Map(function(i, d) set_dim(y[i, , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else if (is.array(y)) {
        n <- dim(y)[2:3]
        Map(function(i, d) set_dim(y[i, , , drop = FALSE], c(d,
            n)), info$index, info$dim)
    } else {
        Map(function(i, d) set_dim(y[i], d), info$index, info$dim)
    }
})
